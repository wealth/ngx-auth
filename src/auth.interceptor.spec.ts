import { TestBed, inject, fakeAsync, tick } from '@angular/core/testing';
import {
  HttpClient,
  HTTP_INTERCEPTORS,
  HttpErrorResponse,
  HttpRequest
} from '@angular/common/http';
import {
  HttpClientTestingModule,
  HttpTestingController
} from '@angular/common/http/testing';
import { Observable, of } from 'rxjs';

import { AuthService } from './auth.service';
import { AUTH_SERVICE } from './tokens';
import { AuthInterceptor } from './auth.interceptor';

const TEST_URI = 'TEST_URI';
const TEST_URI2 = 'TEST_URI_2';
const TEST_REFRESH_URI = 'TEST_REFRESH_URI';
const TEST_TOKEN = 'TEST_TOKEN';

function ObservableDelay<T>(val: T, delay: number, cb = () => {}): Observable<any> {
  return new Observable(observer => {
    setTimeout(() => {
      observer.next(val);
      observer.complete();
      cb();
    }, delay);
  });
}

class AuthenticationServiceStub implements AuthService {
  isAuthorized() {
    return of(true);
  }
  getAccessToken() {
    return of(TEST_TOKEN);
  }
  refreshToken() {
    return of(TEST_TOKEN);
  }
  refreshShouldHappen(e: HttpErrorResponse) {
    return e.status === 401;
  }
  verifyTokenRequest(req: HttpRequest<any>) {
    return req.url === TEST_REFRESH_URI;
  }
}

describe('AuthInterceptor', () => {
  let http: HttpClient;
  let service: AuthService;
  let controller: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [ HttpClientTestingModule ],
      providers: [
        {
          provide: AUTH_SERVICE,
          useClass: AuthenticationServiceStub
        },
        {
          provide: HTTP_INTERCEPTORS,
          useClass: AuthInterceptor,
          multi: true,
        }
      ]
    });
  });

  beforeEach(inject(
    [ HttpClient, HttpTestingController, AUTH_SERVICE ],
    (
      _http: HttpClient,
      _controller: HttpTestingController,
      _service: AuthService
    ) => {
      http = _http;
      controller = _controller;
      service = _service;
    }
  ));

  describe('with request', () => {

    it('should pass request normally', () => {
      http.get(TEST_URI).subscribe(data => {
        expect(data).toEqual({ name: 'Test_Data' });
      }, fail);

      const req = controller.expectOne(TEST_URI);

      expect(req.request.url).toBe(TEST_URI);
      expect(req.request.headers.get('Authorization')).toBe(`Bearer ${TEST_TOKEN}`);

      req.flush({name: 'Test_Data'});
    });

  });

  describe('with responseError', () => {

    it('should throw error', () => {
      http.get(TEST_URI).subscribe(fail, e => {
        expect(e.status).toBe(400);
      });

      controller
        .expectOne(TEST_URI)
        .error(new ErrorEvent('400'), { status: 400 });
    });

    it('should trigger refresh request after failed original request and retry original', fakeAsync(() => {
      spyOn(service, 'refreshToken').and.returnValue(ObservableDelay(TEST_TOKEN, 1000, () => {
        controller
          .expectOne(TEST_URI)
          .flush({ name: 'Test_Data' });
      }));

      http.get(TEST_URI).subscribe((data) => {
        expect(data).toEqual({ name: 'Test_Data' });
        expect(service.refreshToken).toHaveBeenCalled();
      }, fail);

      controller
        .expectOne(TEST_URI)
        .error(new ErrorEvent('401'), { status: 401 });

      tick(1000);
    }));

  });

  describe('with delaying', () => {

    it('should delay and then retry requests if one of requests fails when refreshShouldHappen', fakeAsync(() => {
      spyOn(service, 'refreshToken').and.returnValue(ObservableDelay(TEST_TOKEN, 1000, () => {
        controller
          .expectOne(TEST_URI)
          .flush({name: 'Test_Data'});

        controller
          .expectOne(TEST_URI2)
          .flush({name: 'Test_Data2'});
      }));

      http.get(TEST_URI).subscribe((data) => {
        expect(data).toEqual({ name: 'Test_Data' });
        expect(service.refreshToken).toHaveBeenCalled();
      }, fail);

      http.get(TEST_URI2).subscribe(data => {
        expect(data).toEqual({ name: 'Test_Data2' });
      }, fail);

      controller
        .expectOne(TEST_URI)
        .error(new ErrorEvent('401'), { status: 401 });

      tick(500);

      controller
        .expectOne(TEST_URI2)
        .error(new ErrorEvent('401'), { status: 401 });

      tick(500);

      controller.verify();
    }));

    it('should delay upcoming requests if refresh is in progress', fakeAsync(() => {
      spyOn(service, 'refreshToken').and.returnValue(ObservableDelay(TEST_TOKEN, 1000, () => {
        controller
          .expectOne(TEST_URI)
          .flush({name: 'Test_Data'});

        controller
          .expectOne(TEST_URI2)
          .flush({name: 'Test_Data2'});
      }));

      http.get(TEST_URI).subscribe((data) => {
        expect(data).toEqual({ name: 'Test_Data' });
        expect(service.refreshToken).toHaveBeenCalled();
      }, fail);

      controller
        .expectOne(TEST_URI)
        .error(new ErrorEvent('401'), { status: 401 });

      tick(500);

      http.get(TEST_URI2).subscribe(data => {
        expect(data).toEqual({ name: 'Test_Data2' });
      }, fail);

      // At this point second request is delayed and won't be registered in http

      controller.expectNone(TEST_URI2);

      tick(500);

      controller.verify();
    }));

  });

});

class CustomHeaderAuthenticationServiceStub extends AuthenticationServiceStub {
  public getHeaders(token: string): any {
    return { 'x-auth-token': token };
  }
}

describe('AuthInterceptor', () => {
  let http: HttpClient;
  let controller: HttpTestingController;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [ HttpClientTestingModule ],
      providers: [
        {
          provide: AUTH_SERVICE,
          useClass: CustomHeaderAuthenticationServiceStub
        },
        {
          provide: HTTP_INTERCEPTORS,
          useClass: AuthInterceptor,
          multi: true,
        }
      ]
    });
  });

  beforeEach(inject(
    [ HttpClient, HttpTestingController ],
    (
      _http: HttpClient,
      _controller: HttpTestingController
    ) => {
      http = _http;
      controller = _controller;
    }
  ));

  describe('with custom headers', () => {
    it('should customize the authorization headers', () => {
      http.get(TEST_URI).subscribe(data => {
        expect(data).toEqual({ name: 'Test_Data' });
      }, fail);

      const req = controller.expectOne(TEST_URI);

      expect(req.request.headers.get('x-auth-token')).toBe(TEST_TOKEN);

      req.flush({name: 'Test_Data'});
    });

  });
});
