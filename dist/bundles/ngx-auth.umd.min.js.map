{
  "version": 3,
  "file": "ngx-auth.umd.min.js",
  "sources": [
    "ng://ngx-auth/out/auth.service.ts",
    "ng://ngx-auth/out/tokens.ts",
    "ng://ngx-auth/out/public.guard.ts",
    "ng://ngx-auth/out/protected.guard.ts",
    "ng://ngx-auth/out/auth.interceptor.ts",
    "ng://ngx-auth/out/auth.module.ts"
  ],
  "sourcesContent": [
    "import { HttpRequest, HttpErrorResponse } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n/**\n * Essential service for authentication\n * @export\n */\nexport abstract class AuthService {\n\n  /**\n   * Check, if user already authorized.\n   *\n   * Should return Observable with true or false values\n   */\n  public abstract isAuthorized(): Observable<boolean>;\n\n  /**\n   * Get access token\n   *\n   * Should return access token in Observable from e.g.\n   * localStorage\n   */\n  public abstract getAccessToken(): Observable<string>;\n\n  /**\n   * Function, that should perform refresh token verifyTokenRequest\n   *\n   * Should be successfully completed so interceptor\n   * can execute pending requests or retry original one\n   */\n  public abstract refreshToken(): Observable<any>;\n\n  /**\n   * Function, checks response of failed request to determine,\n   * whether token be refreshed or not.\n   *\n   * Essentially checks status\n   */\n  public abstract refreshShouldHappen(response: HttpErrorResponse): boolean;\n\n  /**\n   * Verify that outgoing request is refresh-token,\n   * so interceptor won't intercept this request\n   */\n  public abstract verifyTokenRequest(req: HttpRequest<any>): boolean;\n\n  /**\n   * Add token to headers, dependent on server\n   * set-up, by default adds a bearer token.\n   * Called by interceptor.\n   *\n   * To change behavior, override this method.\n   */\n  public abstract getHeaders?(token: string, req: HttpRequest<any>): { [name: string]: string | string[] };\n}\n",
    "import { InjectionToken } from '@angular/core';\n\nexport const AUTH_SERVICE = new InjectionToken('AUTH_SERVICE');\nexport const PUBLIC_FALLBACK_PAGE_URI = new InjectionToken('PUBLIC_FALLBACK_PAGE_URI');\nexport const PROTECTED_FALLBACK_PAGE_URI = new InjectionToken('PROTECTED_FALLBACK_PAGE_URI');\n",
    "import { Injectable, Inject } from '@angular/core';\nimport {\n  CanActivate,\n  CanActivateChild,\n  Router,\n  ActivatedRouteSnapshot,\n  RouterStateSnapshot\n} from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { AuthService } from './auth.service';\nimport { AUTH_SERVICE, PROTECTED_FALLBACK_PAGE_URI } from './tokens';\n\n/**\n * Guard, checks access token availability and allows or disallows access to page,\n * and redirects out\n *\n * usage: { path: 'test', component: TestComponent, canActivate: [ PublicGuard ] }\n *\n * @export\n */\n@Injectable()\nexport class PublicGuard implements CanActivate, CanActivateChild {\n\n  constructor(\n    @Inject(AUTH_SERVICE) private authService: AuthService,\n    @Inject(PROTECTED_FALLBACK_PAGE_URI) private protectedFallbackPageUri: string,\n    private router: Router\n  ) {}\n\n  /**\n   * CanActivate handler\n   */\n  public canActivate(\n    _route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable<boolean> {\n    return this.authService.isAuthorized()\n      .pipe(map((isAuthorized: boolean) => {\n        if (isAuthorized && !this.isProtectedPage(state)) {\n          this.navigate(this.protectedFallbackPageUri);\n\n          return false;\n        }\n\n        return true;\n      }));\n  }\n\n  /**\n   * CanActivateChild handler\n   */\n  public canActivateChild(\n    route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable<boolean> {\n    return this.canActivate(route, state);\n  }\n\n  /**\n   * Check, if current page is protected fallback page\n   */\n  private isProtectedPage(state: RouterStateSnapshot): boolean {\n    return state.url === this.protectedFallbackPageUri;\n  }\n\n  /**\n   * Navigate away from the app / path\n   */\n  private navigate(url: string): void {\n    if (url.startsWith('http')) {\n      window.location.href = url;\n    } else {\n      this.router.navigateByUrl(url);\n    }\n  }\n\n}\n",
    "import { Injectable, Inject } from '@angular/core';\nimport {\n  Router,\n  CanActivate,\n  CanActivateChild,\n  ActivatedRouteSnapshot,\n  RouterStateSnapshot\n} from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { AuthService } from './auth.service';\nimport { AUTH_SERVICE, PUBLIC_FALLBACK_PAGE_URI } from './tokens';\n\n/**\n * Guard, checks access token availability and allows or disallows access to page,\n * and redirects out\n *\n * usage: { path: 'test', component: TestComponent, canActivate: [ AuthGuard ] }\n *\n * @export\n */\n@Injectable()\nexport class ProtectedGuard implements CanActivate, CanActivateChild {\n\n  constructor(\n    @Inject(AUTH_SERVICE)private authService: AuthService,\n    @Inject(PUBLIC_FALLBACK_PAGE_URI) private publicFallbackPageUri: string,\n    private router: Router\n  ) {}\n\n  /**\n   * CanActivate handler\n   */\n  public canActivate(\n    _route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable<boolean> {\n    return this.authService.isAuthorized()\n      .pipe(map((isAuthorized: boolean) => {\n        if (!isAuthorized && !this.isPublicPage(state)) {\n          this.navigate(this.publicFallbackPageUri);\n\n          return false;\n        }\n\n        return true;\n      }));\n  }\n\n  /**\n   * CanActivateChild handler\n   */\n  public canActivateChild(\n    route: ActivatedRouteSnapshot,\n    state: RouterStateSnapshot\n  ): Observable<boolean> {\n    return this.canActivate(route, state);\n  }\n\n  /**\n   * Check, if current page is public fallback page\n   */\n  private isPublicPage(state: RouterStateSnapshot): boolean {\n    return state.url === this.publicFallbackPageUri;\n  }\n\n  /**\n   * Navigate away from the app / path\n   */\n  private navigate(url: string): void {\n    if (url.startsWith('http')) {\n      window.location.href = url;\n    } else {\n      this.router.navigateByUrl(url);\n    }\n  }\n\n}\n",
    "import { Injectable, Injector } from '@angular/core';\nimport {\n  HttpClient,\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n  HttpErrorResponse\n} from '@angular/common/http';\nimport { Subject, Observable, throwError } from 'rxjs';\nimport { map, first, switchMap, catchError } from 'rxjs/operators';\n\nimport { AuthService } from './auth.service';\nimport { AUTH_SERVICE } from './tokens';\n\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n\n  /**\n   * Is refresh token is being executed\n   */\n  private refreshInProgress = false;\n\n  /**\n   * Notify all outstanding requests through this subject\n   */\n  private refreshSubject: Subject<boolean> = new Subject<boolean>();\n\n  constructor(private injector: Injector) {}\n\n  /**\n   * Intercept an outgoing `HttpRequest`\n   */\n  public intercept(\n    req: HttpRequest<any>,\n    delegate: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    const authService: AuthService =\n      this.injector.get<AuthService>(AUTH_SERVICE);\n\n    if (authService.verifyTokenRequest(req)) {\n      return delegate.handle(req);\n    }\n\n    return this.processIntercept(req, delegate);\n  }\n\n  /**\n   * Process all the requests via custom interceptors.\n   */\n  private processIntercept(\n    original: HttpRequest<any>,\n    delegate: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    const clone: HttpRequest<any> = original.clone();\n\n    return this.request(clone)\n      .pipe(\n        switchMap((req: HttpRequest<any>) => delegate.handle(req)),\n        catchError((res: HttpErrorResponse) => this.responseError(clone, res))\n      );\n  }\n\n  /**\n   * Request interceptor. Delays request if refresh is in progress\n   * otherwise adds token to the headers\n   */\n  private request(req: HttpRequest<any>): Observable<HttpRequest<any>> {\n    if (this.refreshInProgress) {\n      return this.delayRequest(req);\n    }\n\n    return this.addToken(req);\n  }\n\n  /**\n   * Failed request interceptor, check if it has to be processed with refresh\n   */\n  private responseError(\n    req: HttpRequest<any>,\n    res: HttpErrorResponse\n  ): Observable<HttpEvent<any>> {\n    const authService: AuthService =\n      this.injector.get<AuthService>(AUTH_SERVICE);\n    const refreshShouldHappen: boolean =\n      authService.refreshShouldHappen(res);\n\n    if (refreshShouldHappen && !this.refreshInProgress) {\n      this.refreshInProgress = true;\n\n      authService\n        .refreshToken()\n        .subscribe(\n          () => {\n            this.refreshInProgress = false;\n            this.refreshSubject.next(true);\n          },\n          () => {\n            this.refreshInProgress = false;\n            this.refreshSubject.next(false);\n          }\n        );\n    }\n\n    if (refreshShouldHappen && this.refreshInProgress) {\n      return this.retryRequest(req, res);\n    }\n\n    return throwError(res);\n  }\n\n  /**\n   * Add access token to headers or the request\n   */\n  private addToken(req: HttpRequest<any>): Observable<HttpRequest<any>> {\n    const authService: AuthService =\n      this.injector.get<AuthService>(AUTH_SERVICE);\n\n    return authService.getAccessToken()\n      .pipe(\n        map((token: string) => {\n          if (token) {\n            let setHeaders: { [name: string]: string | string[] };\n\n            if (typeof authService.getHeaders === 'function') {\n              setHeaders = authService.getHeaders(token, req);\n            } else {\n              setHeaders = { Authorization: `Bearer ${token}` };\n            }\n\n            return req.clone({ setHeaders });\n          }\n\n          return req;\n        }),\n        first()\n      );\n  }\n\n  /**\n   * Delay request, by subscribing on refresh event, once it finished, process it\n   * otherwise throw error\n   */\n  private delayRequest(req: HttpRequest<any>): Observable<HttpRequest<any>> {\n    return this.refreshSubject.pipe(\n      first(),\n      switchMap((status: boolean) =>\n        status ? this.addToken(req) : throwError(req)\n      )\n    );\n  }\n\n  /**\n   * Retry request, by subscribing on refresh event, once it finished, process it\n   * otherwise throw error\n   */\n  private retryRequest(\n    req: HttpRequest<any>,\n    res: HttpErrorResponse\n  ): Observable<HttpEvent<any>> {\n    const http: HttpClient =\n      this.injector.get<HttpClient>(HttpClient);\n\n    return this.refreshSubject.pipe(\n      first(),\n      switchMap((status: boolean) =>\n        status ? http.request(req) : throwError(res || req)\n      )\n    );\n  }\n\n}\n",
    "import { NgModule } from '@angular/core';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\n\nimport { PublicGuard } from './public.guard';\nimport { ProtectedGuard } from './protected.guard';\nimport { AuthInterceptor } from './auth.interceptor';\n\n@NgModule({\n  providers: [\n    PublicGuard,\n    ProtectedGuard,\n    AuthInterceptor,\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: AuthInterceptor,\n      multi: true,\n    }\n  ]\n})\nexport class AuthModule {\n}\n"
  ],
  "names": [
    "AuthService",
    "AUTH_SERVICE",
    "InjectionToken",
    "PUBLIC_FALLBACK_PAGE_URI",
    "PROTECTED_FALLBACK_PAGE_URI",
    "PublicGuard",
    "authService",
    "protectedFallbackPageUri",
    "router",
    "this",
    "prototype",
    "canActivate",
    "_route",
    "state",
    "_this",
    "isAuthorized",
    "pipe",
    "map",
    "isProtectedPage",
    "navigate",
    "canActivateChild",
    "route",
    "url",
    "startsWith",
    "window",
    "location",
    "href",
    "navigateByUrl",
    "type",
    "Injectable",
    "decorators",
    "Inject",
    "args",
    "String",
    "Router",
    "ProtectedGuard",
    "publicFallbackPageUri",
    "isPublicPage",
    "AuthInterceptor",
    "injector",
    "refreshInProgress",
    "refreshSubject",
    "Subject",
    "intercept",
    "req",
    "delegate",
    "get",
    "verifyTokenRequest",
    "handle",
    "processIntercept",
    "original",
    "clone",
    "request",
    "switchMap",
    "catchError",
    "res",
    "responseError",
    "delayRequest",
    "addToken",
    "refreshShouldHappen",
    "refreshToken",
    "subscribe",
    "next",
    "retryRequest",
    "throwError",
    "getAccessToken",
    "token",
    "setHeaders",
    "getHeaders",
    "Authorization",
    "first",
    "status",
    "http",
    "HttpClient",
    "Injector",
    "AuthModule",
    "NgModule",
    "providers",
    "provide",
    "HTTP_INTERCEPTORS",
    "useClass",
    "multi"
  ],
  "mappings": "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"
}
